<!DOCTYPE html>
<html>
	<head>
		<title>vwtt.(Vikram)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"> 
    
    <link rel="stylesheet" type="text/css" href="css/jquery.jscrollpane.custom.css" />
    <link rel="stylesheet" type="text/css" href="css/style.css" />
	</head>
	<body>		
		<div id="hs-container" class="hs-container">
      <aside class="hs-menu" id="hs-menu">
				<div class="hs-headline">
					<h1>Hi there, I'm Vikram!</h1>
					<span>Happy coding!</span>
				</div>
				<nav>
					<a href="/index.html"<span>Home</span></a>
					<a href="/about/index.html"><span>About</span></a>
					<a href="/blog/index.html"><span>Blog</span></a>
				</nav>
        <footer>
      		<ul>
          <li><a href="https://in.linkedin.com/in/vikramsrirangam">linkedin</a></li>
        	 <li><a href="https://github.com/vwtt">github</a></li>
  			 </ul>
	   	 </footer>
			</aside>
			<a href="#hs-menu" class="hs-totop-link">Go to the top</a>

      <div class="hs-content-scroller">
  				<div class="hs-content-wrapper">
  					<article class="hs-content" id="introduction">
  						<div class="hs-inner">
                <h2>About Me:</h2>

                <p>brag here!!</p>
                <ul class="posts">
                  <li><span>20-Feb-2016</span> >> <a href="#" title="Some">Some SomeSome SomeSome SomeSome SomeSome Some</a></li>
                  <li><span>20-Feb-2016</span> >> <a href="#" title="Some">Awesome</a></li>
                  <li><span>20-Feb-2016</span> >> <a href="#" title="Some">Tiresome</a></li>
                  <li><span>20-Feb-2016</span> >> <a href="#" title="Some">Something</a></li>
                </ul>               
                
                
                <h2>Some SomeSome SomeSome SomeSome SomeSome Some</h2>
                <p class="meta">20-Feb-2016</p>
                                
                <div class="post">
                  <p>In fact, there is a third intermediate stage between active and inactive. When the object is in this
                    stage, the application can access it but the GC can also deallocate it. There is an obvious contradiction
                    in this stage since the object can be accessed meaning it is referenced and if referenced, it
                    cannot be destroyed. To understand this contradiction, we have to introduce the concept of a weak
                    reference. When an object is referenced by a weak reference, it is both accessible by the application
                    and deallocatable by the GC.
                    Why and when should you use weak references?
                    A developer can use a weak reference on an object if it satisfies all of the following conditions:
                    • The objects might be used later but we are unsure. If we are certain to reuse it later, you should
                    be using a strong reference.
                    • The object can be reconstructed if needed (from a database for example). If we potentially need
                    this object later but cannot reconstruct it, we cannot allow the GC to destroy it.
                    • The object is relatively large in memory (several KB). If the object is lightweight, we can keep
                    it in memory. However, when the two previous conditions apply to a large number of lightweight
                    objects, it is a good idea to use weak references to each of these objects.
                    All of this is theoretical. In practice, we say that we are using an object cache. In fact, these
                    conditions are all fulfilled by objects contained in a cache (we talk of cache from a conceptual
                    point of view and not of a particular implementation).
                    The use of caches can be considered as a natural and automatic compromise in the use of memory,
                    processor power and network bandwidth. When a cache is too large, a portion of its cached objects
                    are destroyed. However, under the assumption that we will need to access one of these objects
                    later, we will need to use processing power and bandwidth to reconstruct the object as needed
                    To summarize, if you need to implement a cache, we recommend the use of weak references.
                    How to use weak references?
                    The use of weak references is facilitated through
                  </p>
                </div>
                
  							<h2>Introduction</h2>
  							
  							<p>some lengthy text/description</p>
                <p>In fact, there is a third intermediate stage between active and inactive. When the object is in this
                  stage, the application can access it but the GC can also deallocate it. There is an obvious contradiction
                  in this stage since the object can be accessed meaning it is referenced and if referenced, it
                  cannot be destroyed. To understand this contradiction, we have to introduce the concept of a weak
                  reference. When an object is referenced by a weak reference, it is both accessible by the application
                  and deallocatable by the GC.
                  Why and when should you use weak references?
                  A developer can use a weak reference on an object if it satisfies all of the following conditions:
                  • The objects might be used later but we are unsure. If we are certain to reuse it later, you should
                  be using a strong reference.
                  • The object can be reconstructed if needed (from a database for example). If we potentially need
                  this object later but cannot reconstruct it, we cannot allow the GC to destroy it.
                  • The object is relatively large in memory (several KB). If the object is lightweight, we can keep
                  it in memory. However, when the two previous conditions apply to a large number of lightweight
                  objects, it is a good idea to use weak references to each of these objects.
                  All of this is theoretical. In practice, we say that we are using an object cache. In fact, these
                  conditions are all fulfilled by objects contained in a cache (we talk of cache from a conceptual
                  point of view and not of a particular implementation).
                  The use of caches can be considered as a natural and automatic compromise in the use of memory,
                  processor power and network bandwidth. When a cache is too large, a portion of its cached objects
                  are destroyed. However, under the assumption that we will need to access one of these objects
                  later, we will need to use processing power and bandwidth to reconstruct the object as needed
                  To summarize, if you need to implement a cache, we recommend the use of weak references.
                  How to use weak references?
                  The use of weak references is facilitated through
                </p>
                <p>In fact, there is a third intermediate stage between active and inactive. When the object is in this
                  stage, the application can access it but the GC can also deallocate it. There is an obvious contradiction
                  in this stage since the object can be accessed meaning it is referenced and if referenced, it
                  cannot be destroyed. To understand this contradiction, we have to introduce the concept of a weak
                  reference. When an object is referenced by a weak reference, it is both accessible by the application
                  and deallocatable by the GC.
                  Why and when should you use weak references?
                  A developer can use a weak reference on an object if it satisfies all of the following conditions:
                  • The objects might be used later but we are unsure. If we are certain to reuse it later, you should
                  be using a strong reference.
                  • The object can be reconstructed if needed (from a database for example). If we potentially need
                  this object later but cannot reconstruct it, we cannot allow the GC to destroy it.
                  • The object is relatively large in memory (several KB). If the object is lightweight, we can keep
                  it in memory. However, when the two previous conditions apply to a large number of lightweight
                  objects, it is a good idea to use weak references to each of these objects.
                  All of this is theoretical. In practice, we say that we are using an object cache. In fact, these
                  conditions are all fulfilled by objects contained in a cache (we talk of cache from a conceptual
                  point of view and not of a particular implementation).
                  The use of caches can be considered as a natural and automatic compromise in the use of memory,
                  processor power and network bandwidth. When a cache is too large, a portion of its cached objects
                  are destroyed. However, under the assumption that we will need to access one of these objects
                  later, we will need to use processing power and bandwidth to reconstruct the object as needed
                  To summarize, if you need to implement a cache, we recommend the use of weak references.
                  How to use weak references?
                  The use of weak references is facilitated through
                </p>
                <p>In fact, there is a third intermediate stage between active and inactive. When the object is in this
                  stage, the application can access it but the GC can also deallocate it. There is an obvious contradiction
                  in this stage since the object can be accessed meaning it is referenced and if referenced, it
                  cannot be destroyed. To understand this contradiction, we have to introduce the concept of a weak
                  reference. When an object is referenced by a weak reference, it is both accessible by the application
                  and deallocatable by the GC.
                  Why and when should you use weak references?
                  A developer can use a weak reference on an object if it satisfies all of the following conditions:
                  • The objects might be used later but we are unsure. If we are certain to reuse it later, you should
                  be using a strong reference.
                  • The object can be reconstructed if needed (from a database for example). If we potentially need
                  this object later but cannot reconstruct it, we cannot allow the GC to destroy it.
                  • The object is relatively large in memory (several KB). If the object is lightweight, we can keep
                  it in memory. However, when the two previous conditions apply to a large number of lightweight
                  objects, it is a good idea to use weak references to each of these objects.
                  All of this is theoretical. In practice, we say that we are using an object cache. In fact, these
                  conditions are all fulfilled by objects contained in a cache (we talk of cache from a conceptual
                  point of view and not of a particular implementation).
                  The use of caches can be considered as a natural and automatic compromise in the use of memory,
                  processor power and network bandwidth. When a cache is too large, a portion of its cached objects
                  are destroyed. However, under the assumption that we will need to access one of these objects
                  later, we will need to use processing power and bandwidth to reconstruct the object as needed
                  To summarize, if you need to implement a cache, we recommend the use of weak references.
                  How to use weak references?
                  The use of weak references is facilitated through
                </p>
                <p>In fact, there is a third intermediate stage between active and inactive. When the object is in this
                  stage, the application can access it but the GC can also deallocate it. There is an obvious contradiction
                  in this stage since the object can be accessed meaning it is referenced and if referenced, it
                  cannot be destroyed. To understand this contradiction, we have to introduce the concept of a weak
                  reference. When an object is referenced by a weak reference, it is both accessible by the application
                  and deallocatable by the GC.
                  Why and when should you use weak references?
                  A developer can use a weak reference on an object if it satisfies all of the following conditions:
                  • The objects might be used later but we are unsure. If we are certain to reuse it later, you should
                  be using a strong reference.
                  • The object can be reconstructed if needed (from a database for example). If we potentially need
                  this object later but cannot reconstruct it, we cannot allow the GC to destroy it.
                  • The object is relatively large in memory (several KB). If the object is lightweight, we can keep
                  it in memory. However, when the two previous conditions apply to a large number of lightweight
                  objects, it is a good idea to use weak references to each of these objects.
                  All of this is theoretical. In practice, we say that we are using an object cache. In fact, these
                  conditions are all fulfilled by objects contained in a cache (we talk of cache from a conceptual
                  point of view and not of a particular implementation).
                  The use of caches can be considered as a natural and automatic compromise in the use of memory,
                  processor power and network bandwidth. When a cache is too large, a portion of its cached objects
                  are destroyed. However, under the assumption that we will need to access one of these objects
                  later, we will need to use processing power and bandwidth to reconstruct the object as needed
                  To summarize, if you need to implement a cache, we recommend the use of weak references.
                  How to use weak references?
                  The use of weak references is facilitated through
                </p>
                <p>In fact, there is a third intermediate stage between active and inactive. When the object is in this
                  stage, the application can access it but the GC can also deallocate it. There is an obvious contradiction
                  in this stage since the object can be accessed meaning it is referenced and if referenced, it
                  cannot be destroyed. To understand this contradiction, we have to introduce the concept of a weak
                  reference. When an object is referenced by a weak reference, it is both accessible by the application
                  and deallocatable by the GC.
                  Why and when should you use weak references?
                  A developer can use a weak reference on an object if it satisfies all of the following conditions:
                  • The objects might be used later but we are unsure. If we are certain to reuse it later, you should
                  be using a strong reference.
                  • The object can be reconstructed if needed (from a database for example). If we potentially need
                  this object later but cannot reconstruct it, we cannot allow the GC to destroy it.
                  • The object is relatively large in memory (several KB). If the object is lightweight, we can keep
                  it in memory. However, when the two previous conditions apply to a large number of lightweight
                  objects, it is a good idea to use weak references to each of these objects.
                  All of this is theoretical. In practice, we say that we are using an object cache. In fact, these
                  conditions are all fulfilled by objects contained in a cache (we talk of cache from a conceptual
                  point of view and not of a particular implementation).
                  The use of caches can be considered as a natural and automatic compromise in the use of memory,
                  processor power and network bandwidth. When a cache is too large, a portion of its cached objects
                  are destroyed. However, under the assumption that we will need to access one of these objects
                  later, we will need to use processing power and bandwidth to reconstruct the object as needed
                  To summarize, if you need to implement a cache, we recommend the use of weak references.
                  How to use weak references?
                  The use of weak references is facilitated through
                </p>
              </div>
  					</article>
          </div><!-- hs-content-wrapper -->
  			</div><!-- hs-content-scroller -->
    </div>		
	</body>
</html>
